e$indeterminate <- e$Gauche_droite == "Indeterminate"
e$gauche_droite_nsp <- as.character(e$gauche_droite)
e$gauche_droite_nsp[e$Gauche_droite=='Indeterminate'] <- 'NSP'
e$gauche_droite_nsp <- as.factor(e$gauche_droite_nsp)
e$gauche_droite_nsp <- relevel(relevel(e$gauche_droite_nsp, "Gauche"), "Extrême gauche")
temp <- Label(e$interet_politique)
e$interet_politique <- 1*(e$interet_politique=='Un peu') + 2*(e$interet_politique=='Beaucoup')
e$interet_politique <- as.item(e$interet_politique, labels=structure(c(0:2), names=c('Presque pas', 'Un peu', 'Beaucoup')), annotation=temp)
e$gilets_jaunes[e$gilets_jaunes_NSP==T] <- -0.1
e$gilets_jaunes[e$gilets_jaunes_compris==T] <- 0 # total à 115%
e$gilets_jaunes[e$gilets_jaunes_oppose==T] <- -1 # 2 oppose et soutien en même temps
e$gilets_jaunes[e$gilets_jaunes_soutien==T] <- 1
e$gilets_jaunes[e$gilets_jaunes_dedans==T] <- 2
e$gilets_jaunes <- as.item(e$gilets_jaunes, missing.values=-0.1, labels = structure(c(-0.1,-1:2), names=c('NSP', "s'oppose", 'comprend', 'soutient', 'en est')),
annotation="gilets_jaunes: Que pensez-vous des gilets jaunes ? -1: s'oppose / 0: comprend sans soutenir ni s'opposer / 1: soutient / 2: fait partie des gilets jaunes (gilets_jaunes_compris/oppose/soutien/dedans/NSP)" )
e$Gilets_jaunes <- as.character(e$gilets_jaunes)
e$Gilets_jaunes[e$gilets_jaunes=="NSP"] <- "NSP"
e$Gilets_jaunes <- as.factor(e$Gilets_jaunes)
e$Gilets_jaunes <- relevel(e$Gilets_jaunes, 'soutient')
e$Gilets_jaunes <- relevel(e$Gilets_jaunes, 'comprend')
e$Gilets_jaunes <- relevel(e$Gilets_jaunes, 'NSP')
e$Gilets_jaunes <- relevel(e$Gilets_jaunes, "s'oppose")
label(e$Gilets_jaunes) <- "Gilets_jaunes: Que pensez-vous des gilets jaunes ? -1: s'oppose / 0: comprend sans soutenir ni s'opposer / 1: soutient / 2: fait partie des gilets jaunes (gilets_jaunes_compris/oppose/soutien/dedans/NSP)"
e$echelle_politique_CC <- -2*(e$echelle_politique_CC=='à toutes les échelles') -1*(e$echelle_politique_CC=='mondiales') + (e$echelle_politique_CC=='nationales') + 2*(e$echelle_politique_CC=='locales')
e$echelle_politique_CC <- as.item(e$echelle_politique_CC, labels = structure(c(-2:2), names=c('à toutes les échelles', "mondiale", 'européenne', 'nationale', 'locale')), annotation=Label(e$echelle_politique_CC) )
# e$echelle_politique_CC <- relevel(as.factor(e$echelle_politique_CC), 'nationales')
# e$echelle_politique_CC <- relevel(e$echelle_politique_CC, 'européennes')
# e$echelle_politique_CC <- relevel(e$echelle_politique_CC, 'mondiales')
# e$echelle_politique_CC <- relevel(e$echelle_politique_CC, 'à toutes les échelles')
e$statut_emploi[e$statut_emploi=="autre actif/ve"] <- "autre actif"
e$statut_emploi[e$statut_emploi=="inactif/ve"] <- "inactif"
e$retraites <- e$statut_emploi == 'retraité·e'
e$actifs <- e$statut_emploi %in% c("autre actif", "CDD", "CDI", "fonctionnaire", "intérimaire ou contrat précaire")
e$etudiants <- e$statut_emploi == 'étudiant·e'
e$inactif <- e$statut_emploi %in% c("inactif", "au chômage")
label(e$retraites) <- "retraites: statut_emploi == 'retraité·e'"
label(e$actifs) <- 'actifs: statut_emploi %in% c("autre actif", "CDD", "CDI", "fonctionnaire", "intérimaire ou contrat précaire")'
label(e$etudiants) <- "etudiants: statut_emploi == 'étudiant·e'"
label(e$inactif) <- 'inactif: statut_emploi %in% c("inactif", "au chômage")'
e$single <- 1*(e$nb_adultes==1)
label(e$single) <- "single: nb_adultes == 1"
region_code <- function(code) {
reg <- "autre"
regions <- list(
"ARA" = c('01', '03', '07', '15', '26', '38', '42', '43', '63', '69', '73', '74'),
"Est" = c('21', '25', '39', '58', '70', '71', '89', '90', '08', '10', '51', '52', '54', '55', '57', '67', '68', '88'),
"Ouest" = c('22', '29', '35', '56', '14', '27', '50', '61', '76' ),
"Centre" = c('18', '28', '36', '37', '41', '45', '44', '49', '53', '72', '85'),
"Nord" = c('02', '59', '60', '62', '80'),
"IDF" = c('75', '77', '78', '91', '92', '93', '94', '95'),
"SO" = c('16', '17', '19', '23', '24', '33', '40', '47', '64', '79', '86', '87'),
"Occ" = c('09', '11', '12', '30', '31', '32', '34', '46', '48', '65', '66', '81', '82'),
"PACA" = c( '04', '05', '06', '13', '83', '84')
)
for (i in 1:9) if (as.numeric(code) %in% as.numeric(regions[[i]])) reg <- names(regions)[i]
return(reg)
}
region_dep <- rep("", 95)
for (i in 1:95) region_dep[i] <- region_code(i)
e$region_verif <- "autre"
e$region_verif[as.numeric(substr(e$code_postal, 1, 2)) %in% 1:95] <- region_dep[as.numeric(substr(e$code_postal, 1, 2))][as.numeric(substr(e$code_postal, 1, 2)) %in% 1:95]
e$region[is.na(e$region)] <- 'autre'
e$nb_vehicules_verif <- (e$nb_vehicules_texte=='Un') + 2*(e$nb_vehicules_texte=='Deux ou plus')
e$km[!is.na(e$km_0)] <- e$km_0[!is.na(e$km_0)]
e$km[!is.na(e$km_1)] <- e$km_1[!is.na(e$km_1)]
e$km[!is.na(e$km_2)] <- e$km_2[!is.na(e$km_2)]
label(e$km) <- "km: Nombre de kilomètres parcourus lors des 12 derniers mois en voiture ou moto (par le répondant pour nb_vehicules=0, par les véhicules sinon)"
if (vague==1) {
e$conso[!is.na(e$conso_1)] <- e$conso_1[!is.na(e$conso_1)]
e$conso[!is.na(e$conso_2)] <- e$conso_2[!is.na(e$conso_2)]
e$conso[is.na(e$conso)] <- (6.39 + 7.31) / 2 # R round(0.5)=0 (JS = 1) and the code here does not exploit the fact that we may know whether it's diesel or essence: conso_embedded is better, but exists only for e2
} else e$conso <- n(e$conso_embedded)
label(e$conso) <- "conso:  Consommation moyenne du véhicule (en litres aux 100 km)"
# e$mauvaise_qualite[e$conso > 90] <- 1 + e$mauvaise_qualite[e$conso > 90] # 28
e$km_original <- e$km
e$conso_original <- e$conso
e$surface_original <- e$surface
e$km <- pmin(e$km, 200000) # TODO ?? e$km[877] <- 1130 [586] <- 2250
e$conso <- pmin(e$conso, 30) # e$conso[851] <- 6.1
e$surface <- pmin(e$surface, 650) #
e$conso_1 <- pmin(e$conso_1, 30) #
e$conso_2 <- pmin(e$conso_2, 30) #
e$age_18_24 <- 1*(e$age == '18-24')
e$age_25_34 <- 1*(e$age == '25-34')
e$age_35_49 <- 1*(e$age == '35-49')
e$age_50_64 <- 1*(e$age == '50-64')
e$age_65_plus <- 1*(e$age == '65+')
e$tax_approval <- e$taxe_approbation=='Oui'
e$tax_acceptance <- e$taxe_approbation!='Non'
label(e$tax_approval) <- "tax_approval: Approbation initiale de la hausse de la taxe carbone compensée: taxe_approbation=='Oui'"
label(e$tax_acceptance) <- "tax_acceptance: Acceptation initiale de la hausse de la taxe carbone compensée: taxe_approbation!='Non'"
# TODO!: simule_gagnant faux (?), vague 2, gagnant_alternative_categorie/tax_alternative_acceptance
if (vague==1) {
e$tax_feedback_approval <- e$taxe_feedback_approbation=='Oui'
e$tax_feedback_acceptance <- e$taxe_feedback_approbation!='Non'
label(e$tax_feedback_approval) <- "tax_feedback_approval: Approbation après le feedback de la hausse de la taxe carbone compensée: taxe_feedback_approbation=='Oui'"
label(e$tax_feedback_acceptance) <- "tax_feedback_acceptance: Acceptation après le feedback de la hausse de la taxe carbone compensée: taxe_feedback_approbation!='Non'"
e$update_correct <- ((e$simule_gagnant==1 & e$gagnant_feedback_categorie=='Gagnant' & e$gagnant_categorie!='Gagnant')
+ (e$simule_gagnant==0 & e$gagnant_feedback_categorie=='Perdant' & e$gagnant_categorie!='Perdant')
- (e$simule_gagnant==1 & e$gagnant_feedback_categorie=='Perdant' & e$gagnant_categorie!='Perdant')
- (e$simule_gagnant==0 & e$gagnant_feedback_categorie=='Gagnant' & e$gagnant_categorie!='Gagnant'))
label(e$update_correct) <- "update_correct: Différence entre l'indicatrice de ne pas se penser gagnant/perdant et le penser après feedback infirmant, moins la même après feedback confirmant"
e$update_correct_large <- ((e$simule_gagnant==1 & ((e$gagnant_feedback_categorie=='Gagnant' & e$gagnant_categorie!='Gagnant') | (e$gagnant_feedback_categorie!='Perdant' & e$gagnant_categorie=='Perdant')))
+ (e$simule_gagnant==0 & ((e$gagnant_feedback_categorie=='Perdant' & e$gagnant_categorie!='Perdant') | (e$gagnant_feedback_categorie!='Gagnant' & e$gagnant_categorie=='Gagnant')))
- (e$simule_gagnant==1 & ((e$gagnant_feedback_categorie=='Perdant' & e$gagnant_categorie!='Perdant') | (e$gagnant_feedback_categorie!='Gagnant' & e$gagnant_categorie=='Gagnant')))
- (e$simule_gagnant==0 & ((e$gagnant_feedback_categorie=='Gagnant' & e$gagnant_categorie!='Gagnant') | (e$gagnant_feedback_categorie!='Perdant' & e$gagnant_categorie=='Perdant'))))
label(e$update_correct_large) <- "update_correct_large: Différence entre faire un update dans la bonne direction quand le feedback y conduit et faire un update dans la mauvaise direction"
e$feedback_confirme <- (e$gagnant_categorie=='Gagnant' & e$simule_gagnant==1) | (e$gagnant_categorie=='Perdant' & e$simule_gagnant==0)
e$feedback_infirme <- (e$gagnant_categorie=='Perdant' & e$simule_gagnant==1) | (e$gagnant_categorie=='Gagnant' & e$simule_gagnant==0)
e$feedback_confirme_large <- e$feedback_confirme | (e$gagnant_categorie!='Perdant' & e$simule_gagnant==1) | (e$gagnant_categorie!='Gagnant' & e$simule_gagnant==0)
e$feedback_infirme_large <- e$feedback_infirme | (e$gagnant_categorie!='Perdant' & e$simule_gagnant==0) | (e$gagnant_categorie!='Gagnant' & e$simule_gagnant==1)
label(e$feedback_confirme) <- "feedback_confirme: Indicatrice de se penser et être simulé gagnant/perdant (gagnant_categorie, simule_gagnant)"
label(e$feedback_infirme) <- "feedback_infirme: Indicatrice de se penser gagnant et être simulé perdant, ou l'inverse (gagnant_categorie, simule_gagnant)"
label(e$feedback_confirme_large) <- "feedback_confirme_large: Indicatrice de se penser non perdant et être simulé gagnant, ou de se penser non gagnant et être simulé perdant (gagnant_categorie, simule_gagnant)"
label(e$feedback_infirme_large) <- "feedback_infirme_large: Indicatrice de se penser non gagnant et être simulé gagnant, ou de se penser non perdant et être simulé perdant (gagnant_categorie, simule_gagnant)"
e$winning_category <- as.factor(e$gagnant_categorie)
e$winning_feedback_category <- as.factor(e$gagnant_feedback_categorie)
levels(e$winning_category) <- c('Winner', 'Unaffected', 'Loser')
levels(e$winning_feedback_category) <- c('Winner', 'Unaffected', 'Loser')
label(e$winning_category) <- "Winning category before feedback"
label(e$winning_feedback_category) <- "Winning category after feedback"
} else {
e$variante_alternative <- ifelse(e$dividende != 170 & e$random != 0, "urba", "détaxe")
label(e$variante_alternative) <- "variante_alternative: Variante affiché pour taxe avec dividende alternative: urba/détaxe. urba: Dividende différencié en fonction du lieu d'habitation (88-133e centre-ville - rural). détaxe: 1tCO2 gratuite/pers (50e remboursable e.g. en station-service), le reste reversé en dividende."
}
#   e$gaz <- grepl('gaz', e$chauffage, ignore.case = T)
#   e$fioul <- grepl('fioul', e$chauffage, ignore.case = T)
#   e$hausse_chauffage <- -55.507189 + e$gaz * 124.578484 + e$fioul * 221.145441 + e$surface * 0.652174
# hausses telles que calculées sans bug. Ces calculs ne sont valables que pour e1; pour e2 on a mis à jour les prix de l'essence etc. dans qualtrics, donc la version non _verif est plus correcte
e$hausse_diesel_verif[e$nb_vehicules == 0] <- (0.5*(6.39/100) * e$km * 1.4 * (1 - 0.4) * 0.090922)[e$nb_vehicules == 0] # share_diesel * conso * km * price * (1-elasticite) * price_increase
e$hausse_diesel_verif[e$nb_vehicules == 1] <- ((e$fuel_1=='Diesel') * (ifelse(is.na(e$conso_1), 6.39, e$conso_1)/100) * e$km * 1.4 * (1 - 0.4) * 0.090922)[e$nb_vehicules == 1] # DONE: replaced e$conso
e$hausse_diesel_verif[e$nb_vehicules == 2] <- (((e$fuel_2_1=='Diesel')*2/3 + (e$fuel_2_2=='Diesel')/3) * (ifelse(is.na(e$conso_2), 6.39, e$conso_2)/100) * e$km * 1.4 * (1 - 0.4) * 0.090922)[e$nb_vehicules == 2]
e$hausse_essence_verif[e$nb_vehicules == 0] <- (0.5*(7.31/100) * e$km * 1.45 * (1 - 0.4) * 0.076128)[e$nb_vehicules == 0] # share_diesel * conso * km * price * (1-elasticite) * price_increase
e$hausse_essence_verif[e$nb_vehicules == 1] <- ((e$fuel_1!='Diesel') * (ifelse(is.na(e$conso_1), 7.31, e$conso_1)/100) * e$km * 1.45 * (1 - 0.4) * 0.076128)[e$nb_vehicules == 1]
e$hausse_essence_verif[e$nb_vehicules == 2] <- (((e$fuel_2_1!='Diesel')*2/3 + (e$fuel_2_2!='Diesel')/3) * (ifelse(is.na(e$conso_2), 7.31, e$conso_2)/100) * e$km * 1.45 * (1 - 0.4) * 0.076128)[e$nb_vehicules == 2]
# hausses sans tenir compte de la conso renseignée
e$hausse_diesel_verif_na[e$nb_vehicules == 0] <- (0.5*(6.39/100) * e$km * 1.4 * (1 - 0.4) * 0.090922)[e$nb_vehicules == 0] # share_diesel * conso * km * price * (1-elasticite) * price_increase
e$hausse_diesel_verif_na[e$nb_vehicules == 1] <- ((e$fuel_1=='Diesel') * (6.39/100) * e$km * 1.4 * (1 - 0.4) * 0.090922)[e$nb_vehicules == 1] # DONE: replaced e$conso
e$hausse_diesel_verif_na[e$nb_vehicules == 2] <- (((e$fuel_2_1=='Diesel')*2/3 + (e$fuel_2_2=='Diesel')/3) * (6.39/100) * e$km * 1.4 * (1 - 0.4) * 0.090922)[e$nb_vehicules == 2]
e$hausse_essence_verif_na[e$nb_vehicules == 0] <- (0.5*(7.31/100) * e$km * 1.45 * (1 - 0.4) * 0.076128)[e$nb_vehicules == 0] # share_diesel * conso * km * price * (1-elasticite) * price_increase
e$hausse_essence_verif_na[e$nb_vehicules == 1] <- ((e$fuel_1!='Diesel') * (7.31/100) * e$km * 1.45 * (1 - 0.4) * 0.076128)[e$nb_vehicules == 1]
e$hausse_essence_verif_na[e$nb_vehicules == 2] <- (((e$fuel_2_1!='Diesel')*2/3 + (e$fuel_2_2!='Diesel')/3) * (7.31/100) * e$km * 1.45 * (1 - 0.4) * 0.076128)[e$nb_vehicules == 2]
# bug: conso_2=NA pour conso_2_choix=NSP & fuel_2_1=Diesel, créant le même bug simule_gagnant=1 et hausse_depenses=NA decrit(e1$fuel_2_1[e1$bug==F & is.na(e1$hausse_depenses)]) decrit(e1$conso_2_choix[e1$bug==F & is.na(e1$hausse_depenses)]) (bug de nouveau dans le pilote 2)
# c'était dû à une coquille (conso_2_1 était écrit au lieu de conso2_1). ça concerne 17 obs. parmi les 190 premières, i.e. pour date_enregistree <= "2020-10-09 03:06:24"
e$bug <- e$date_enregistree < "2020-04-28 05:55:00" # 1:792: T / 793:1003: F
e$bug_touche <- (e$fuel_2_1=='Diesel' &  !is.na(e$fuel_2_1)) & e$bug
e$hausse_depenses_verif <- e$hausse_diesel_verif + e$hausse_essence_verif + e$hausse_chauffage # hausses telles que calculées sans bug (celle utilisée pour bug==F)
e$hausse_depenses_verif_na <- e$hausse_diesel_verif_na + e$hausse_essence_verif_na + e$hausse_chauffage # hausses sans tenir compte de la conso renseignée (celle utilisée pour bug==T)
e$feedback_correct <- (round(e$conso)==7 & !(e$fuel_2_1 %in% c('Diesel'))) | (!e$bug)
# /!\ avant 28/04 18h55 FR, hausse_diesel et _essence correspondaient à _verif_na, i.e. la conso renseignée n'étaient pas prise en compte. Il y avait un bug quand fuel_2_1 == Diesel, de sorte que tous ces gens avaient le feedback Gagnant et conso = NaN
#   e$hausse_carburants <- e$hausse_diesel + e$hausse_essence
#   e$depense_carburants <- (e$hausse_diesel / 0.090922 + e$hausse_essence / 0.076128) / (1 - 0.4)
#   label(e$hausse_carburants) <- "hausse_carburant: Hausse des dépenses de carburants simulées pour le ménage, suite à la taxe (élasticité de 0.4) (hausse_diesel + hausse_essence)"
#   label(e$depense_carburants) <- "depense_carburants: Dépense de carburants annuelle estimée du ménage, avant la réforme"
#   e$hausse_depenses <- e$hausse_carburants + e$hausse_chauffage
e$diesel <- (!is.na(e$fuel_1) & (e$fuel_1=='Diesel')) | (!is.na(e$fuel_2_2) & ((e$fuel_2_1=='Diesel') | (e$fuel_2_2=='Diesel')))
e$essence <- (!is.na(e$fuel_1) & (e$fuel_1=='Essence')) | (!is.na(e$fuel_2_2) & ((e$fuel_2_1=='Essence') | (e$fuel_2_2=='Essence')))
label(e$diesel) <- "diesel: Indicatrice de la possession d'un véhicule diesel par le ménage (fuel_1 ou fuel_2_1 ou fuel_2_2 = 'Diesel')"
label(e$essence) <- "essence: Indicatrice de la possession d'un véhicule à essence par le ménage (fuel_1 ou fuel_2_1 ou fuel_2_2 = 'Essence')"
e$revenu_conjoint <- e$rev_tot - e$revenu
e$revdisp <- round((e$rev_tot -  irpp(e$rev_tot, e$nb_adultes, e$taille_menage)))
e$uc <- uc(e$taille_menage, e$nb_14_et_plus)
e$niveau_vie <- e$revdisp / e$uc
e$fioul <- n(e$fioul)
e$gaz <- n(e$gaz)
if (vague==1) {
e$perte <- 1 + round(as.numeric(gsub("\\D*", "", sub("\\set.*", "", sub("\\D*", "", e$hausse_depenses_subjective))))/45)
e$perte[grepl('au contraire', e$hausse_depenses_subjective)] <- -1
e$perte[grepl('aucune baisse', e$hausse_depenses_subjective)] <- 0
label(e$perte) <- "perte: Catégorie de hausse_depenses_subjective par UC, suite à hausse taxe carbone compensée, dans [-1;5] (seuils: 0/1/30/70/120/190)"
e$perte_echelle <- e$perte
label(e$perte) <- "perte: Catégorie de hausse_depenses_subjective (€ par UC par an), suite à hausse taxe carbone compensée, dans [-1;5] (seuils: 0/1/30/70/120/190)"
# cf. consistency_belief_losses.py pour les imputations. Average of BdF in each bin has been used.
e$perte_min <- -30*(e$perte==-1) + 1*(e$perte==1) + 30*(e$perte==2) + 70*(e$perte==3) + 120*(e$perte==4) + 190*(e$perte==5)
e$perte_max <-   0*(e$perte==-1) + 30*(e$perte==1) + 70*(e$perte==2) + 120*(e$perte==3) + 190*(e$perte==4) + 2000*(e$perte==5)
temp <- 224.25*(e$perte==5) + 147.91*(e$perte==4) + 92.83*(e$perte==3) + 48.28*(e$perte==2) + 13.72*(e$perte==1) - 1.66*(e$perte==-1) # TODO?: recalculer, surtout perte==5 (qui correspond à [190;280] au lieu de >190) et perte==-1 (ne sait pas d'où il sort). Pour info 405.55*(perte==6)
e$perte <- as.item(temp, labels = structure(c(224.25, 147.91, 92.83, 48.28, 13.72, 0, -1.66), names = c(">190", "120-190", "70-120", "30-70", "0-30", "0", "<0")), annotation=Label(e$perte))
e$simule_gain_menage <- 16.1 + pmin(2, e$nb_adultes) * 110 - e$hausse_depenses # NA pour les répondants chez qui le fuel_2_1=='Diesel' créait un bug (et qui avait tout le temps simule_gagnant==1) (élasticité de 0.15 sur le gaz)
e$simule_gain_repondant <- 16.1 + 110 - e$hausse_depenses
label(e$simule_gain_repondant) <- "simule_gain_repondant: Gain net annuel simulé pour le répondant (sans tenir compte du potentiel versement reçu par les autres adultes du ménage) suite à une hausse de taxe carbone compensée: 116.1 - hausse_depenses"
e$simule_gain_verif <- (16.1 + pmin(2, e$nb_adultes) * 110 - e$hausse_depenses_verif) / e$uc # élasticité de 0.15 sur le gaz
label(e$simule_gain_verif) <- "simule_gain_verif: Gain net annuel simulé par UC suite à une hausse de taxe carbone compensée (avec le bon calcul)"
# TODO: refaire pour vague==2
e$hausse_carburants <- e$hausse_diesel_verif + e$hausse_essence_verif
e$hausse_chauffage_interaction_inelastique <- 152.6786*e$fioul + e$surface * (1.6765*e$gaz + 1.1116*e$fioul) # TODO
e$depense_chauffage <- ((1*(e$fioul) * (152.6786 + 1.1116*e$surface)) / 0.148079 + 1.6765*e$gaz*e$surface / 0.133456)
e$hausse_depenses_interaction <- e$hausse_carburants + e$hausse_chauffage_interaction_inelastique * (1 - 0.2)
e$hausse_depenses_interaction_inelastique <- e$hausse_carburants/(1 - 0.4) + e$hausse_chauffage_interaction_inelastique
e$simule_gain_interaction <- (9.1 + pmin(2, e$nb_adultes) * 110 - e$hausse_depenses_interaction) / e$uc # élasticité de 0.2 pour le gaz
e$simule_gagnant_interaction <- 1*(e$simule_gain_interaction > 0)
e$simule_gain_inelastique <- (pmin(2, e$nb_adultes) * 110 - e$hausse_depenses_interaction_inelastique) / e$uc # élasticité nulle. Inclure + 22.4 rendrait le taux d'erreur uniforme suivant les deux catégories, on ne le fait pas pour être volontairement conservateur
label(e$hausse_chauffage_interaction_inelastique) <- "hausse_chauffage_interaction_inelastique: Hausse des dépenses de chauffage simulées pour le ménage avec des termes d'interaction entre surface et gaz/fioul plutôt que sans, suite à la taxe (élasticité nulle)"
label(e$depense_chauffage) <- "depense_chauffage: Dépense de chauffage annuelle estimée du ménage, avant la réforme"
label(e$simule_gain_interaction) <- "simule_gain_interaction: Gain net par UC annuel simulé avec des termes d'interaction surface*fioul/gaz pour le ménage du répondant suite à une hausse de taxe carbone compensée: 9.1 + pmin(2, nb_adultes) * 110 - hausse_chauffage_interaction_inelastique * 0.8 - hausse_carburants"
label(e$simule_gagnant_interaction) <- "simule_gagnant_interaction: Indicatrice sur la prédiction que le ménage serait gagnant avec la taxe compensée, d'après nos simulations avec des termes d'interaction surface*fioul/gaz: 1*(simule_gain_interaction > 0)"
label(e$simule_gain_inelastique) <- "simule_gain_inelastique: Gain net par UC annuel simulé (avec interaction) avec une élasticité nulle, pour le ménage du répondant suite à une hausse de taxe carbone compensée:  nb_adultes * 110 - hausse_chauffage_interaction_inelastique - hausse_carburants / 0.6"
# label(e$simule_gain_elast_perso) <- "simule_gain_elast_perso: Gain net par UC annuel simulé (avec interaction) avec l'élasticité renseignée par le répondant, pour le ménage du répondant suite à une hausse de taxe carbone compensée: pmin(2, nb_adultes) * 110 - hausse_partielle_inelastique * (1 - Elasticite_partielle_perso) - hausse_autre_partielle"
label(e$hausse_depenses_interaction) <- "hausse_depenses_interaction: Hausse des dépenses énergétiques simulées pour le ménage avec les termes d'interaction, suite à la taxe (élasticité de 0.4/0.2 pour carburants/chauffage)"
label(e$hausse_depenses_interaction_inelastique) <- "hausse_depenses_interaction_inelastique: Hausse des dépenses énergétiques simulées pour le ménage avec les termes d'interaction, suite à la taxe (élasticité nulle)"
} else {
e$dividende <- n(e$dividende)
e$simule_gain_menage <- e$nb_adultes * e$dividende - e$hausse_depenses # gain fiscal utilisé pour hausse_depenses, alors que dans v1 c'est gain budget
}
e$simule_gain <- e$simule_gain_menage / e$uc
label(e$simule_gain_menage) <- "simule_gain_menage: Gain net annuel simulé pour le ménage du répondant suite à une hausse de taxe carbone compensée, ajusté à la vague et valeur du dividende. Vague 1: 16.1 + pmin(2, nb_adultes) * 110 - hausse_depenses (gain budget). Vague 2: nb_adultes * dividende - hausse_depenses (gain fiscal)"
label(e$simule_gain) <- "simule_gain: Gain net annuel simulé par UC pour le ménage du répondant suite à une hausse de taxe carbone compensée, ajusté à la vague et valeur du dividende. /!\ v1: gain budget / v2: gain fiscal utilisé. (simule_gain_menage/UC)"
e$Revenu <- e$revenu/1e3 # TODO: labels
e$Revenu_conjoint <- e$revenu_conjoint/1e3
e$percentile_revenu <- 100*percentiles_revenu(e$revenu*12)
e$percentile_revenu_conjoint  <- 100*percentiles_revenu(e$revenu_conjoint*12)
e$Simule_gain <- e$simule_gain/1e3
e$Revenu2 <- e$revenu^2/1e6
e$Revenu_conjoint2 <- e$revenu_conjoint^2/1e6
e$Simule_gain2 <- e$simule_gain^2/1e6
if (vague==1) e$origine_taxe <- relevel(as.factor(e$origine_taxe), 'gouvernement') # inconnue
else e$origine_taxe <- relevel(as.factor(e$origine_taxe), 'gouvernement')
if (vague==1) e$label_taxe <- relevel(as.factor(e$label_taxe), 'taxe')
e$variante_taxe_carbone <- relevel(as.factor(e$variante_taxe_carbone), 'neutre')
label(e$variante_taxe_carbone) <- "variante_taxe_carbone: Variante aléatoire pour pour_taxe_carbone: neutre/pour/contre: no info / Selon un sondage de 2018/2019, une majorité de Français est pour/contre une augmentation de la taxe carbone"
e$hausse_depenses_par_uc <- e$hausse_depenses/e$uc # TODO: hausse_depenses_interaction_par_uc
label(e$hausse_depenses_par_uc) <- "hausse_depenses_par_uc: Hausse des dépenses énergétiques par UC suite à la taxe (utilise la variable buggué hausse_depenses) (élasticité de 0.4/0.2 pour carburants/chauffage)"
e$hausse_depenses_verif_par_uc <- e$hausse_depenses_verif/e$uc # TODO: hausse_depenses_interaction_par_uc
label(e$hausse_depenses_verif_par_uc) <- "hausse_depenses_verif_par_uc: Hausse des dépenses énergétiques par UC suite à la taxe (élasticité de 0.4/0.2 pour carburants/chauffage)"
if (vague==1) { # TODO!
e$biais <- e$hausse_depenses_verif_par_uc - as.numeric(e$perte)
e$biais_plus <- e$hausse_depenses_verif_par_uc - as.numeric(e$perte_min)
e$biais_moins <- e$hausse_depenses_verif_par_uc - as.numeric(e$perte_max)
label(e$biais) <- "biais: hausse_depenses_par_uc - perte Différence entre la hausse objective et subjective (moyenne de l'intervalle) de dépenses par UC d'énergies fossiles:  (< 0 : pessimisme sur les dépenses)"
label(e$biais_plus) <- "biais_plus: hausse_depenses_par_uc - perte_min Différence entre la hausse objective et subjective (min de l'intervalle) de dépenses par UC d'énergies fossiles: (< 0 : pessimisme sur les dépenses)"
label(e$biais_moins) <- "biais_moins: hausse_depenses_par_uc - perte_max Différence entre la hausse objective et subjective (max de l'intervalle) de dépenses par UC d'énergies fossiles: (< 0 : pessimisme sur les dépenses)"
e$gain <- (110/e$uc)*pmin(2, e$nb_adultes)*(e$confiance_dividende + 1)/2 - e$perte
label(e$gain) <- "gain: (110/uc)*min(2, nb_adultes)*(confiance_dividende == Oui + 0.5*confiance_dividende == À moitié) - perte Gain net par UC subjectif du ménage suite à une taxe carbone avec dividende, en tenant compte que le répondant peut croire que son ménage ne recevra pas, ou à moitié, le dividende."
e$gain_min <- (110/e$uc)*pmin(2, e$nb_adultes)*(e$confiance_dividende==1) - e$perte_max
label(e$gain_min) <- "gain: (110/uc)*min(2, nb_adultes)*(confiance_dividende == Oui) - perte_max Gain net par UC subjectif du ménage suite à une taxe carbone avec dividende, où le dividende est ajouté seulement si le répondant y croit"
e$biais_sur <- abs(e$simule_gain - e$gain) > 110
label(e$biais_sur) <- "biais_sur: Certitude à 99% que le gain subjectif du répondant est biaisé à la baisse: abs(simule_gain - gain) > 110"
}
# e$nb_politiques_env <- 0
# variables_politiques_environnementales <- c("taxe_kerosene", "taxe_viande", "normes_isolation", "normes_vehicules", "controle_technique", "interdiction_polluants",
#                                             "peages_urbains", "fonds_mondial") # "rattrapage_diesel"
# for (v in variables_politiques_environnementales) e$nb_politiques_env[e[[v]]>0] <- 1 + e$nb_politiques_env[e[[v]]>0]
variables_politiques_1 <<- paste('pour', c("fin_gaspillage", "cantines_vertes", "voies_reservees", "densification", "renouvelables", "taxe_distance"), sep='_') # 6
variables_politiques_2 <<- paste('pour', c("bonus_malus", "aides_train", "fonds_mondial", "taxe_viande", "conditionner_aides", "restriction_centre_ville", "limitation_110", "obligation_renovation"), sep='_') # 8
variables_referendum <<- paste('referendum', c("obligation_renovation", "cheque_bio", "interdiction_publicite", "interdiction_polluants", "taxe_dividendes", "consigne"), sep='_') # 6
variables_politiques_env <<- c(variables_politiques_1, variables_politiques_2, variables_referendum) # 20
e$nb_referenda <- e$nb_politiques_2 <- e$nb_politiques_1 <- 0
for (v in variables_referendum) e$nb_referenda[e[[v]]>0] <- 1 + e$nb_referenda[e[[v]]>0]
for (v in variables_politiques_2) e$nb_politiques_2[e[[v]]>0] <- 1 + e$nb_politiques_2[e[[v]]>0]
for (v in variables_politiques_1) e$nb_politiques_1[e[[v]]>0] <- 1 + e$nb_politiques_1[e[[v]]>0]
e$nb_referenda_politiques_2 <- e$nb_referenda + e$nb_politiques_2
e$nb_politiques_env <- e$nb_referenda + e$nb_politiques_1 # TODO: add carbon tax
e$prop_referenda <- e$nb_referenda / 6
e$prop_politiques_1 <- e$nb_politiques_1 / 6
e$prop_politiques_2 <- e$nb_politiques_2 / 8
e$prop_referenda_politiques_2 <- e$nb_referenda_politiques_2 / 14
e$prop_politiques_env <- e$nb_politiques_env / 20
label(e$nb_referenda) <- "nb_referenda: Nombre de referendum_ où le répondant voterait Oui (cf. les 6 variables_referendum) ~ info_CCC"
label(e$nb_politiques_1) <- "nb_politiques_1: Nombre de politiques environnementales de la 1ère partie soutenues par le répondant (cf. les 6 variables_politiques_1)"
label(e$nb_politiques_2) <- "nb_politiques_2: Nombre de politiques environnementales de la 2è partie soutenues par le répondant (cf. les 6 variables_politiques_2) ~ info_CCC"
label(e$nb_politiques_env) <- "nb_politiques_env: Nombre de politiques environnementales soutenues par le répondant = nb_referenda + nb_politiques_1 + nb_politiques_2 (cf. les 20 variables_politiques_env)"
label(e$nb_referenda_politiques_2) <- "nb_referenda_politiques_2: Nombre de politiques environnementales de la 2è partie soutenues par le répondant = nb_referenda + nb_politiques_2 (cf. les 14 variables_politiques_2 et variables_referendum)"
label(e$prop_referenda) <- "prop_referenda: Proportion de referendum_ où le répondant voterait Oui (cf. les 6 variables_referendum) ~ info_CCC"
label(e$prop_politiques_1) <- "prop_politiques_1: Proportion de politiques environnementales de la 1ère partie soutenues par le répondant (cf. les 6 variables_politiques_1)"
label(e$prop_politiques_2) <- "prop_politiques_2: Proportion de politiques environnementales de la 2è partie soutenues par le répondant (cf. les 6 variables_politiques_2) ~ info_CCC"
label(e$prop_politiques_env) <- "prop_politiques_env: Proportion de politiques environnementales soutenues par le répondant = prop_referenda + prop_politiques_1 + prop_politiques_2 (cf. les 20 variables_politiques_env)"
label(e$prop_referenda_politiques_2) <- "prop_referenda_politiques_2: Proportion de politiques environnementales de la 2è partie soutenues par le répondant = nb_referenda + nb_politiques_2 (cf. les 14 variables_politiques_2 et variables_referendum)"
e$correct_soutenu_bonus_malus <- e$soutenu_bonus_malus==T # ~65% pour
e$correct_soutenu_normes_isolation <- e$soutenu_normes_isolation==T # AT: 72% pour
e$correct_soutenu_obligation_renovation <- e$soutenu_obligation_renovation==T # referendum_obligation_renovation: ~75% Oui / pour_obligation_renovation: ~83% pour
e$correct_soutenu_limitation_110 <- e$soutenu_limitation_110==F # pour_limitation_110: ~53% contre
e$nb_correct_soutenu <- e$correct_soutenu_bonus_malus + e$correct_soutenu_normes_isolation + e$correct_soutenu_obligation_renovation + e$correct_soutenu_limitation_110
label(e$correct_soutenu_bonus_malus) <- "correct_soutenu_bonus_malus: soutenu_bonus_malus==T - Un renforcement du bonus/malus écologique pour l’achat d’un véhicule - Réponse correcte à si cette politique est soutenue par une majorité de Français (obligation_renovation/normes_isolation/bonus_malus/limitation_110)"
label(e$correct_soutenu_obligation_renovation) <- "correct_soutenu_obligation_renovation: soutenu_obligation_renovation==T - L'obligation de rénovation thermique des logements les moins bien isolés assortie d'aides de l'État - Réponse correcte à si cette politique est soutenue par une majorité de Français (obligation_renovation/normes_isolation/bonus_malus/limitation_110)"
label(e$correct_soutenu_limitation_110) <- "correct_soutenu_limitation_110: soutenu_limitation_110==F - L'abaissement de la limitation de vitesse sur les autoroutes à 110 km/h - Réponse correcte à si cette politique est soutenue par une majorité de Français (obligation_renovation/normes_isolation/bonus_malus/limitation_110)"
label(e$correct_soutenu_normes_isolation) <- "correct_soutenu_normes_isolation: soutenu_normes_isolation==T - Des normes plus strictes sur l'isolation pour les nouveaux bâtiments - Réponse correcte à si cette politique est soutenue par une majorité de Français (obligation_renovation/normes_isolation/bonus_malus/limitation_110)"
label(e$nb_correct_soutenu) <- "nb_correct_soutenu: Nombre de réponses correctes à si cette politique est soutenue par une majorité de Français (obligation_renovation/normes_isolation/bonus_malus/limitation_110)"
variables_devoile <<- paste("CCC_devoile", c("obligation_renovation", "limitation_110", "fonds_mondial", "taxe_viande"), sep='_')
if (vague==2) {
variables_devoile <- c(variables_devoile, "CCC_devoile_28_heures")
e$correct_devoile_28_heures <- e$CCC_devoile_28_heures < 0
label(e$correct_devoile_28_heures) <- "correct_devoile_28_heures: CCC_devoile_28_heures < 0 - [Si pas Aucun à sait_CCC_devoilee] La réduction du temps de travail légal à 28 heures par semaine - Réponse correcte à si cette mesure de la CCC a été dévoilée ~ info_CCC"
}
e$correct_devoile_obligation_renovation <- e$CCC_devoile_obligation_renovation > 0 # https://www.lemonde.fr/climat/article/2020/04/11/climat-les-50-propositions-de-la-convention-citoyenne-pour-porter-l-espoir-d-un-nouveau-modele-de-societe_6036293_1652612.html
e$correct_devoile_limitation_110 <- e$CCC_devoile_limitation_110 < 0
e$correct_devoile_fonds_mondial <- e$CCC_devoile_fonds_mondial < 0
e$correct_devoile_taxe_viande <- e$CCC_devoile_taxe_viande < 0
e$nb_correct_devoile <- e$correct_devoile_obligation_renovation + e$correct_devoile_limitation_110 + e$correct_devoile_fonds_mondial + e$correct_devoile_taxe_viande
if (vague==2) e$nb_correct_devoile <- e$nb_correct_devoile + e$correct_devoile_28_heures
label(e$correct_devoile_obligation_renovation) <- "correct_devoile_obligation_renovation: CCC_devoile_obligation_renovation > 0 - [Si pas Aucun à sait_CCC_devoilee] L'obligation de rénovation thermique des logements les moins bien isolés assortie d'aides de l'État - Réponse correcte à si cette mesure de la CCC a été dévoilée ~ info_CCC"
label(e$correct_devoile_limitation_110) <- "correct_devoile_limitation_110: CCC_devoile_limitation_110 < 0 - [Si pas Aucun à sait_CCC_devoilee] L'abaissement de la limitation de vitesse sur les autoroutes à 110 km/h - Réponse correcte à si cette mesure de la CCC a été dévoilée ~ info_CCC"
label(e$correct_devoile_fonds_mondial) <- "correct_devoile_fonds_mondial: CCC_devoile_fonds_mondial < 0 - [Si pas Aucun à sait_CCC_devoilee] Une contribution à un fonds mondial pour le climat - Réponse correcte à si cette mesure de la CCC a été dévoilée ~ info_CCC"
label(e$correct_devoile_taxe_viande) <- "correct_devoile_taxe_viande: CCC_devoile_taxe_viande < 0 - [Si pas Aucun à sait_CCC_devoilee] Une taxe sur la viande rouge - Réponse correcte à si cette mesure de la CCC a été dévoilée ~ info_CCC"
label(e$nb_correct_devoile) <- "nb_correct_devoile: Nombre de réponses correctes à si cette mesure de la CCC a été dévoilée (obligation_renovation=T/limitation_110=F/taxe_viande=F/fonds_mondial=F/[vague 2]28h=F)"
obstacles <<- c("lobbies", "manque_volonte", "manque_cooperation", "inegalites", "incertitudes", "demographie", "technologies", "rien")
variables_obstacles <<- paste("obstacles", obstacles, sep="_")
for (i in 1:8)  {
for (v in obstacles) e[[paste("obstacle", i, sep="_")]][e[[paste("obstacles", v, sep="_")]]==i] <- v
label(e[[paste("obstacle", i, sep="_")]]) <- paste("obstacle_", i, ": Obstacle à la lutte contre le CC classé en position ", i, " (1: le plus - 7: le moins important) (", paste(obstacles, collapse = "/"), ")", sep="") }
e$Connaissance_CCC <- NA
e$connaissance_CCC_bon_francais <- e$connaissance_CCC_sortition <- e$connaissance_CCC_mesures <- e$connaissance_CCC_temporalite <- e$connaissance_CCC_internet <- e$connaissance_CCC == "FALSE"
e$connaissance_CCC_150 <- e$connaissance_CCC == "FALSE"
if (vague==1) {
e$Connaissance_CCC[c(1,3,10,13,17,19,29,30,34,45,49,51,54,57,64,68,74,77,78,86,93,97,103,121,129,136,139,151,153,155,156,159,162,163,164,174,179,181,182,183,184,187,191,194,196,197,201)] <- "aucune" #
e$Connaissance_CCC[c(208,210,217,218,223,232,236,242,250,255,259,260,266,268,271,272,278,282,285,289,291,297,298,301,310,312,313,324,327,328,349,352,355,357,361,372)] <- "aucune" #
e$Connaissance_CCC[c(383,385,389,390,394,402,410,411,415,416,417,419,421,422,424,425,429,431,442,444,446,450,451,457,458,461,463,465,466,468,469,472,476,485,487,488,492)] <- "aucune" # ex: "nsp" 19, 402, # doublons 450-451, 421-422, 468-469, 515-516?
e$Connaissance_CCC[c(496,502,515,516,520,526,532,533,534,535,537,540,541,546,548,550,551,552,553,555,557,560,561,562,564,567,568,572,578,582,584,586,587,588,589,597,598,602,603,604)] <- "aucune" # ex: 598
e$Connaissance_CCC[c(610,619,621,622,625,626,629,630,631,634,636,638,639,650,654,656,657,659,660,665,666,667,669,674,677,678,681,686,688,690,694,698,699,702,707,709,712,713,720,721,725,727)] <- "aucune" # ex: 598
e$Connaissance_CCC[c(731,733,738,747,748,752,753,757,760,762,763,765,766,768,771,772,775,781,782,783,785,787,790,793,798,823,826,830,844,845,846,847,848,859,860,862,865,868,872,873)] <- "aucune" # ex: 598
e$Connaissance_CCC[c(876,891,883,887,893,897,899,908,909,911,913,915,916,917,926,930,939,940,943,944,946,955,956,957,960,962,965,966,967,973,977,978,986,992,995,998,1000,1001,1002,1003)] <- "aucune" # ex: 598, 915
e$Connaissance_CCC[c(73,118,143,239,248,270,280,283,326,381,388,471,489,491,504,590,592,632,743,866,871,929,951,952,993)] <- "faux" # ex: 239, 326
e$Connaissance_CCC[c(6,22,25,66,72,80,90,100,107,110,111,152,166,170,177,188,214,227,238,276,281,316,319,320,323,339,360,387,393,396,399,408,432,452,454,474,498,503)] <- "hors sujet" # ex: 25, 71, 90, 107 # 25-110-432 doublon ?
e$Connaissance_CCC[c(510,570,573,575,591,664,682,715,716,736,737,739,741,744,767,795,839,840,842,849,854,861,892,895,921,927,928,936,945,953,959,964,984,999)] <- "hors sujet" # ex: 25, 71, 90, 107, 570, 767, 839, 840, 861 # 25-110-432 570-573 1001-1003 doublon ? TODO
e$Connaissance_CCC[c(9,31,33,35,37,38,55,59,81,101,120,193,202,233,235,237,249,252,273,293,294,311,358,359,363,367,374,414,434,455,457,460,479,482,484,490,508,519,522,524,538)] <- "trop vague" # ex: 374, 457, 490 [490 = 2.0?]
e$Connaissance_CCC[c(581,614,623,624,628,642,643,645,655,663,671,687,703,704,705,724,746,754,773,780,792,818,886,888,900,901,902,912,934,954)] <- "trop vague" # ex: 374, 457, 490
e$Connaissance_CCC[c(8,15,18,20,26,27,28,43,65,75,84,85,89,101,123,132,135,140,142,144,145,147,165,168,172,176,207,220,222,240,247,275,288,303,308,341,347,348,351,356,364,377,473,493)] <- "approximatif" # ex: 607
e$Connaissance_CCC[c(401,404,423,427,505,506,507,530,531,618,670,672,693,695,696,728,729,732,740,751,758,776,786,796,800,802,831,832,857,875,877,906,914,920,937,938,972,982,987,988)] <- "approximatif"
e$Connaissance_CCC[c(7,24,62,67,71,84,91,106,117,127,130,131,134,150,154,158,173,175,186,202,209,226,246,247,253,262,284,302,307,334,337,380,386,391,400,407,418,420,428,440,448,449,470,481)] <- "bonne" # ex: 24, 117, 334 ; contient généralement mesures, sortition, 150 ou date
e$Connaissance_CCC[c(494,501,514,542,547,558,563,566,607,609,611,613,646,665,684,689,691,700,718,722,770,779,797,811,815,863,898,910,923,935,941,950,991)] <- "bonne" # ex: 24, 117, 334 ; contient généralement mesures, sortition, 150 ou date
e$connaissance_CCC_bon_francais[c(6,15,18,20,24,27,62,84,85,91,130,134,140,145,154,158,165,170,175,193,202,207,220,226,242,247,248,253,262,288,347,348,351,356,360,364,377,380,386,387,391)] <- "bon français" # ex: ; pas de faute d'orthographe, grammaire correcte, phrase élaborée (i.e. pas juste "je ne sais pas")
e$connaissance_CCC_bon_francais[c(399,404,418,419,423,425,434,448,449,454,457,460,470,471,473,481,488,493,501,507,508,522,542,562,581,598,609,611,613,665,691,700,728,729,732,741,752)] <- "bon français" # ex: ; pas de faute d'orthographe, grammaire correcte, phrase élaborée (i.e. pas juste "je ne sais pas")
e$connaissance_CCC_bon_francais[c(770,776,779,796,797,875,877,895,898,935,937,988,991,993)] <- "bon français" # ex: ; pas de faute d'orthographe, grammaire correcte, phrase élaborée (i.e. pas juste "je ne sais pas")
e$connaissance_CCC_sortition[c(7,62,67,71,91,106,127,130,131,134,150,154,158,165,173,175,186,202,207,209,239,246,247,253,262,284,302,308,334,348,380,407,420,428,440,448,449,470,481)] <- "sortition"
e$connaissance_CCC_sortition[c(494,501,514,530,542,547,558,566,607,609,611,613,646,672,684,689,691,693,700,722,751,779,797,811,815,831,832,857,863,898,906,910,914,923,929,941,972,991)] <- "sortition"
e$connaissance_CCC_mesures[c(7,62,67,71,130,135,142,154,175,186,202,226,246,262,302,307,337,356,386,400,404,407,428,448,449,481,494,505,531,558,563,566,607,609,611,613,646,670,689)] <- "mesures"
e$connaissance_CCC_mesures[c(700,718,722,770,779,786,802,811,815,819,863,898,920,938,941,950,982,991,993)] <- "mesures"
e$connaissance_CCC_internet[c(44,70,239,279,512,606,701)] <- "internet"
e$connaissance_CCC_temporalite[c(84,117,131,150,172,235,249,293,302,427,501)] <- "temporalité"
e$connaissance_CCC_150[which(c(grepl('150', e$connaissance_CCC)),470)] <- "150"
} else {
e$connaissance_CCC_opinion <- e$connaissance_CCC_choix <- e$connaissance_CCC_posterite <- e$connaissance_CCC == "FALSE"
e$Connaissance_CCC[c(2,1001,8,14,15,16,17,19,23,24,28,41,44,58,59,64,67,69,76,83,84,90,94,96,98,100,104,105,106,107,112,130,132,133,134,143,145,150,156,157,158,163,164,167,168,171,173,186,428,187)] <- "aucune"
e$Connaissance_CCC[c(191,193,199,206,208,210,214,227,242,248,249,251,255,264,272,274,280,294,309,312,314,316,320,321,323,324,329,331,333,338,340,341,347,349,355,357,364,367,374,376,379,386,387,391,393,394,395,397)] <- "aucune"
e$Connaissance_CCC[c(6,25,26,27,30,35,36,42,49,73,85,87,116,122,123,127,135,147,152,159,166,172,175,180,189,196,203,204,205,222,256,266,277,283,285,291,304,311,319,330,334,337,343,365,369,377)] <- "trop vague" # Réponse aurait pu être déduit simplement à partir du nom "CCC". Impossible de savoir ce que le répondant sait réellement, ou bien le répondant sait des choses à moitié, commet des erreurs.
e$Connaissance_CCC[c(1002,4,7,12,21,22,32,37,39,40,45,46,47,51,52,56,66,75,78,79,88,103,113,115,117,118,121,138,140,141,148,151,153,154,165,182,195,204,218,226,228,232,243,246,252,254,258,259,260,262)] <- "approximatif" # Contient un voire quelques éléments (mesures, sortition) mais mal formulés ou peu clair, ou avec une imprécision. Laisse penser que le répondant connaît mais ne dit pas tout ce qu'il sait. ex; 32
e$Connaissance_CCC[c(275,284,290,293,300,303,306,322,325,326,327,344,346,356,359,363,367,390,396,403,405,406,407,410,416,421,422,431,433,435,440,447,455,453,458,459,463,464,469,480,481,487,490,497)] <- "approximatif"
e$Connaissance_CCC[c(9,18,29,33,34,50,55,57,60,61,65,70,77,109,119,129,136,139,142,145,155,162,178,185,190,197,200,202,209,213,215,217,221,225,229,233,235,237,253,257,265,271,281,288,296,298,302,305)] <- "bonne" # Contient généralement plusieurs éléments (mesures, sortition, 150 ou date) bien articulés permettant de s'assurer que le répondant connaît la CCC. ex: 155
e$connaissance_CCC_mesures[c(1002,4,9,18,21,22,26,29,32,33,34,35,36,40,49,52,55,57,61,70,73,75,77,78,79,82,103,109,115,117,129,136,139,145,148,153,155,182,185,190,197,200,205,209,213,215,217,219)] <- "mesures" # mentionne que des propositions doivent être formulées / ont été formulées # TODO: check les 10 premières voir s'il y a des mesures spécifiques
e$connaissance_CCC_mesures[c(222,228,233,235,236,237,243,246,252,253,254,257,258,260,275,281,288,290,291,293,296,298,302,303,305,317,322,325,326,344,346,350,353,356,358,359,363,366,367,370,371)] <- "mesures"
e$connaissance_CCC_sortition[c(18,32,34,50,55,56,57,60,61,65,70,77,118,121,138,139,142,145,155,162,178,197,200,225,229,233,235,236,237,253,257,259,265,281,288,296,300,302,305,306,317,350,353,356,366)] <- "sortition"
e$connaissance_CCC_bon_francais[c(1002,7,9,12,26,27,29,33,45,50,52,55,60,65,66,70,78,82,88,109,119,121,123,124,129,140,141,142,144,145,148,151,152,155,162,167,169,194,196,202,221,236,238,246,253,254,256)] <- "bon français" # pas de faute d'orthographe, grammaire correcte, phrase élaborée (i.e. pas juste "je ne sais pas")
e$Connaissance_CCC[c(1003,1,5,31,48,114,124,144,198,238,241,278,279,297,328,351,352,354,466,471,493)] <- "hors sujet"
e$Connaissance_CCC[c(38,108,169,188,194,220,271,292,318,348,408,443)] <- "faux"
e$Connaissance_CCC[c(397,399,402,413,415,423,436,437,441,442,444,445,451,452,457,460,472,474,476,479,484,488,489,498)] <- "aucune"
e$Connaissance_CCC[c(380,384,392,398,411,420,425,428,446,450,468,470,475,477,483,491)] <- "trop vague"
e$Connaissance_CCC[c()] <- "approximatif"
e$Connaissance_CCC[c(317,350,353,358,366,370,371,373,375,378,385,389,400,401,409,417,424,430,438,448,453,462,465,478,485,492,495)] <- "bonne"
e$connaissance_CCC_bon_francais[c(257,259,266,277,281,283,284,288,296,302,304,317,334,346,353,356,358,363,365,366,367,370,378,385,390,396,398,405,408,410,417,430,435,443,446,464,465,481)] <- "bon français"
e$connaissance_CCC_sortition[c(371,377,378,385,389,400,401,403,407,409,417,424,438,448,455,465,478,485,492)] <- "sortition"
e$connaissance_CCC_mesures[c(375,373,378,385,389,398,400,401,406,409,416,417,421,424,428,430,433,435,438,448,458,463,465,469,470,477,478,480,483,487,490,492,495,497)] <- "mesures"
e$connaissance_CCC_choix[c(213,215,217,440,447,481)] <- "mesures spécifiques" # (mentionne des mesures spécifiques proposées par la CCC)
e$connaissance_CCC_internet[c(453,462)] <- "internet"
e$connaissance_CCC_temporalite[c(29,34,47,82,139,265,431,438,453)] <- "temporalité" # Évoque la durée ou les dates de la CCC
e$connaissance_CCC_150[which(c(grepl('150', e$connaissance_CCC)),34)] <- "150" # not 75, 127, 139, 182, 190, 233, 359, 458, 487
e$connaissance_CCC_opinion[c(1,5,38,39,42,45,52,66,70,75,108,122,135,138,140,142,151,162,188,195,215,241,243,259,271,279,285,352,359,384,390,428,468,475,477,485)] <- "opinion" # Exprime une opinion à propos de la CCC. ex: 1 "les vrais problemes non pas été traités". ex: 38, 42, 108
e$connaissance_CCC_posterite[c(9,39,40,55,77,82,129,154,165,237,253,298,366,396,400,492)] <- "postérité" # Évoque la postérité réservée aux mesures proposées.
} # TODO: corrélation bon_français et Connaissance / âge / sexe / CSP, mesures et postérité, Connaissance écolo, etc., distribution du nombre de trucs cochés parmi 150/mesures/sortition
# Intéressant pour Laslier: 138 "Des citoyens tirés au sort qui ne représentent qu'eux-mêmes alors que nous avons des élu.e.s pour cela...", 285
# TODO: doublon 400-401? 403-407?
variables_connaissance_CCC <<- c("bon_francais", "sortition", "mesures", "temporalite", "internet", "150")
for (v in variables_connaissance_CCC) e[[paste("connaissance_CCC", v, sep="_")]] <- e[[paste("connaissance_CCC", v, sep="_")]]!="FALSE"
temp <- -2*(e$Connaissance_CCC=="hors sujet") -1*(e$Connaissance_CCC=="faux") + 1*(e$Connaissance_CCC=="trop vague") + 2*(e$Connaissance_CCC=="approximatif") + 3*(e$Connaissance_CCC=="bonne")
temp[e$connaissance_CCC_internet==T] <- 2
e$Connaissance_CCC <- as.item(temp, labels = structure(c(-2:3), names=c("hors sujet", "faux", "aucune", "trop vague", "approximatif", "bonne")),
annotation="Connaissance_CCC: connaissance_CCC recodé en hors sujet/faux/aucune/approximatif/bonne (incl. internet) - Décrivez ce que vous savez de la Convention Citoyenne pour le Climat. (champ libre)")
label(e$connaissance_CCC_bon_francais) <- "connaissance_CCC_bon_francais: Indicatrice que la réponse à connaissance_CCC est constituée d'une phrase grammaticalement correcte et sans faute d'orthographe (à l'exception des phrases très courtes type 'Je ne sais pas')"
label(e$connaissance_CCC_sortition) <- "connaissance_CCC_sortition: Indicatrice que la réponse à connaissance_CCC mentionne le tirage au sort, ou du moins le caractère 'lambda' ou hétérogène des citoyens de la CCC"
label(e$connaissance_CCC_mesures) <- "connaissance_CCC_mesures: Indicatrice que la réponse à connaissance_CCC mentionne le fait que la CCC rend des propositions de mesures"
label(e$connaissance_CCC_temporalite) <- "connaissance_CCC_temporalite: Indicatrice que la réponse à connaissance_CCC mentionne un élément de la temporalité de la CCC (date de début ou de fin, ou fréquence de ses réunions)"
label(e$connaissance_CCC_internet) <- "connaissance_CCC_internet: Indicatrice que la réponse à connaissance_CCC a été copiée à partir des résultats d'une requête internet"
label(e$connaissance_CCC_150) <- "connaissance_CCC_150: Indicatrice que la réponse à connaissance_CCC mentionne le nombre de membres de la CCC (150)" # autre indicatrice qui aurait pu être intéressante : si ça mentionne que la CCC est française ou, au contraire, se méprend en parlant d'une initiative internationale
if (vague==2) {
e$gain_subjectif_original[grepl("pas affecté", e$gain_net_choix)] <- 0
e$gain_subjectif_original[!is.na(e$gain_net_gain)] <- n(e$gain_net_gain[!is.na(e$gain_net_gain)])
e$gain_subjectif_original[!is.na(e$gain_net_perte)] <- - n(e$gain_net_perte[!is.na(e$gain_net_perte)] )
e$gain_subjectif <- e$gain_subjectif_original / e$uc
label(e$gain_subjectif) <- "gain_subjectif: Gain net subjectif par UC pour la taxe avec dividende (variation en partie expliquée par trois valeurs de dividendes aléatoires: 0/110/170)."
e$gain <- pmax(-500, pmin(170, e$gain_subjectif)) # TODO: trim at 110/0 for respective values of dividend / assign NA to outliers
label(e$gain) <- "gain: Gain net subjectif par UC borné (trim) entre -500 et 170 pour la taxe avec dividende (variation en partie expliquée par trois valeurs de dividendes aléatoires: 0/110/170)."
e$gagnant_categorie <- 1*grepl("gagne", e$gain_net_choix) - 0.1*grepl("NSP", e$gain_net_choix) - 1*grepl("perd", e$gain_net_choix)
} else {
e$gagnant_categorie <- 1*(e$gagnant_categorie=="Gagnant") - 0.1*(e$gagnant_categorie=="NSP") - 1*(e$gagnant_categorie=="Perdant")
}
label(e$gagnant_categorie) <- "gagnant_categorie: ~ Ménage Gagnant/Non affecté/Perdant/NSP par taxe avec dividende"
e$gagnant_categorie <- as.item(n(e$gagnant_categorie), labels = structure(c(1:-1,-0.1), names=c('Gagnant', 'Non affecté', 'Perdant', 'NSP')), missing.values = -0.1, annotation=Label(e$gagnant_categorie))
e$Gagnant_categorie <- as.character(e$gagnant_categorie)
e$Gagnant_categorie[e$Gagnant_categorie=="NSP"] <- "NSP "
e$Gagnant_categorie <- relevel(as.factor(as.character(e$Gagnant_categorie)), "Non affecté")
if (vague==1) e$dividende <- 110
else e$label_taxe <- "taxe"
e <- e[, -c(9:17, 131, 132, 134, 136, 137, 139, 187)] # 39:49,
return(e)
}
weighting_e <- function(data, printWeights = T) { # cf. google sheet
d <- data
d$taille_agglo <- as.numeric(d$taille_agglo)
# d$csp <- factor(d$csp)
# d$region <- factor(d$region)
# levels(d$csp) <- c(levels(d$csp),"missing")
# levels(d$region) <- c(levels(d$region),"missing")
# levels(d$taille_agglo) <- c(levels(d$taille_agglo),"missing")
# levels(d$sexe) <- c(levels(d$sexe),"missing")
# d$csp[is.na(d$csp) | d$csp=="" | d$csp=="NSP"] <- "missing"
# d$taille_agglo[is.na(d$taille_agglo)] <- "missing"
# d$sexe[d$sexe=="" | d$sexe=="Autre"] <- "missing"
unweigthed <- svydesign(ids=~1, data=d)
sexe <- data.frame(sexe = c("Féminin", "Masculin"), Freq=nrow(d)*c(0.516,0.484)) # http://www.insee.fr/fr/themes/detail.asp?ref_id=bilan-demo&reg_id=0&page=donnees-detaillees/bilan-demo/pop_age2.htm
csp <- data.frame(csp = c("Inactif", "Ouvrier", "Cadre", "Indépendant", "Intermédiaire", "Retraité", "Employé", "Agriculteur"),
Freq=nrow(d)*c(0.129,0.114,0.101,0.035,0.136,0.325,0.15,0.008))
region <- data.frame(region = c("autre","ARA", "Est", "Nord", "IDF", "Ouest", "SO", "Occ", "Centre", "PACA"),
Freq=nrow(d)*c(0.0001,0.12446,0.12848,0.09237,0.1902,0.10294,0.09299,0.09178,0.09853,0.07831))
age <- data.frame(age = c("18-24", "25-34", "35-49", "50-64", "65+"),
Freq=nrow(d)*c(0.120,0.150,0.240,0.240,0.250)) # Données/estim-pop-reg-sexe...
taille_agglo <- data.frame(taille_agglo = c(1:5), Freq=nrow(d)*c(0.2166,0.1710,0.1408,0.3083,0.1633))
# revenu <- data.frame(revenu = c(), Freq=nrow(d)*c())
diplome4 <- data.frame(diplome4 = c("Aucun diplôme ou brevet", "CAP ou BEP", "Baccalauréat", "Supérieur"),  # http://webcache.googleusercontent.com/search?q=cache:rUvf6u0uCnEJ:www.insee.fr/fr/themes/tableau.asp%3Freg_id%3D0%26ref_id%3Dnattef07232+&cd=1&hl=fr&ct=clnk&gl=fr&lr=lang_en%7Clang_es%7Clang_fr
Freq=nrow(d)*c(0.290, 0.248, 0.169, 0.293))
if (length(which(is.na(d$taille_agglo)))>0) raked <- rake(design= unweigthed, sample.margins = list(~sexe,~diplome4,~region,~csp,~age),
population.margins = list(sexe,diplome4,region,csp,age))
else raked <- rake(design= unweigthed, sample.margins = list(~sexe,~diplome4,~taille_agglo,~region,~csp,~age),
population.margins = list(sexe,diplome4,taille_agglo,region,csp,age))
if (printWeights) {    print(summary(weights(raked))  )
print(paste("(mean w)^2 / (n * mean w^2): ", round(sum( weights(raked) )^2/(length(weights(raked))*sum(weights(raked)^2)), 3), " (pb if < 0.5)")) # <0.5 : problématique
print(paste("proportion not in [0.25; 4]: ", round(length(which(weights(raked)<0.25 | weights(raked)>4))/ length(weights(raked)), 3)))
}
return(weights(trimWeights(raked, lower=0.25, upper=4, strict=TRUE)))
}
# exclude_speeder=TRUE;exclude_screened=TRUE; only_finished=TRUE; only_known_agglo=T; duree_max=630
prepare_e <- function(exclude_speeder=TRUE, exclude_screened=TRUE, only_finished=TRUE, only_known_agglo=T, duree_max=390) { # , exclude_quotas_full=TRUE
e <- read_csv("../donnees/externe1.csv")[-c(1:2),]
e <- relabel_and_rename(e)
print(paste(length(which(e$exclu=="QuotaMet")), "QuotaMet"))
e$fini[e$exclu=="QuotaMet" | is.na(e$revenu)] <- "False" # To check the number of QuotaMet that shouldn't have incremented the quota, comment this line and: decrit(e$each_strate[e$exclu=="QuotaMet" & e$csp=="Employé" & !grepl("2019-03-04 07", e$date)])
if (exclude_screened) { e <- e[is.na(e$exclu),] }
if (exclude_speeder) { e <- e[as.numeric(as.vector(e$duree)) > duree_max,] }
# if (exclude_quotas_full) { e <- e[e[101][[1]] %in% c(1:5),]  } # remove those with a problem for the taille d'agglo
# if (exclude_quotas_full) { e <- e[e$Q_TerminateFlag=="",]  } # remove those with a problem for the taille d'agglo
if (only_finished) { # TODO: le faire marcher même pour les autres
e <- e[e$fini=="True",]
e <- convert_e(e, vague=1)
e$weight <- weighting_e(e)
e$gauche_droite_na <- as.numeric(e$gauche_droite)
e$gauche_droite_na[e$indeterminate == T] <- wtd.mean(e$gauche_droite, weights = e$weight)
} else {
e$Diplome <- (e$diplome == "Brevet des collèges") + 2*(e$diplome=="CAP ou BEP") + 3*(e$diplome=="Baccalauréat") + 4*(e$diplome=="Bac +2 (BTS, DUT, DEUG, écoles de formation sanitaires et sociales...)") + 5*(e$diplome=="Bac +3 (licence...)") + 6*(e$diplome=="Bac +5 ou plus (master, école d'ingénieur ou de commerce, doctorat, médecine, maîtrise, DEA, DESS...)") - (e$diplome=="NSP (Ne se prononce pas)")
e$diplome4 <- as.item(pmin(pmax(e$Diplome, 1), 4), labels = structure(1:4, names = c("Aucun diplôme ou brevet", "CAP ou BEP", "Baccalauréat", "Supérieur")), annotation=Label(e$diplome))
e <- e[, -c(9:17, 131, 132, 134, 136, 137, 139, 187)]
}
e$sample <- "a"
e$sample[e$fini=="True"] <- "e"
e$sample[e$fini=="True" & n(e$duree) > duree_max] <- "p"
e$sample[e$fini=="True" & n(e$duree) > duree_max & e$test_qualite=='Un peu'] <- "f" # "q"? excluded because out of quotas
e$sample[e$fini=="True" & n(e$duree) > duree_max & e$exclu==""] <- "r"
return(e)
}
e1 <- prepare_e()
e1$vague <- 1
eb <- rbind.fill(e1, e2)
for (i in names(eb)) {
if (i %in% names(e1)) label(eb[[i]]) <- label(e1[[i]])
if (i %in% names(e2)) label(eb[[i]]) <- label(e2[[i]]) }
(Connaissance_CCC_v12_wo_label <- barres12(vars = "Connaissance_CCC", color = color(7)[c(1,2,4:7)], miss = F, labels="Synhtesis of the open field"))
(Connaissance_CCC_v12_wo_label <- barres12(vars = "Connaissance_CCC", color = color(7)[c(1,2,4:7)], fr =F, miss = F, labels="Synhtesis of the open field", legend = c("Good", "Vague", "Too vague", "None", "Wrong", "Irrelevant")))
save_plotly(Connaissance_CCC_v12_wo_label)
# TODO: appartenance
(Connaissance_CCC_v12_wo_label <- barres12(vars = "Connaissance_CCC", color = color(7)[c(1,2,4:7)], miss = F, labels="Synhtèse du champ libre"))
save_plotly(Connaissance_CCC_v12_wo_label)
(Connaissance_CCC_v12_wo_label_en <- barres12(vars = "Connaissance_CCC", color = color(7)[c(1,2,4:7)], fr =F, miss = F, labels="Synhtesis of the open field", legend = c("Good", "Vague", "Too vague", "None", "Wrong", "Irrelevant")))
save_plotly(Connaissance_CCC_v12_wo_label_en)
# TODO: appartenance
(Connaissance_CCC_v12_wo_label <- barres12(vars = "Connaissance_CCC", color = color(7)[c(1,2,4:7)], miss = F, labels="Synhtèse du champ libre"))
save_plotly(Connaissance_CCC_v12_wo_label)
(politiques_2_en_v12 <- barres12(variables_politiques_2, labels=labels_variables_politiques_2_en, fr = F, legend = c("Completely", "Rather", "Indifferent/NR", "Not really", "Not at all"), miss=F))
save_plotly(politiques_2_en_v12)
labels_CCC_avis_long <- c("Useless as the government will<br>only take back the measures it likes",
"A promising method to define<br>France's climate policy",
"A hope for institutional renewal",
"An experiment doomed to failure",
"A communication operation<br>of the government",
"A sincere initiative of the<br>government in favor of democracy",
"A way for the government to<br>shirk its responsibilities",
"An opportunity to make the<br>voice of all French people heard",
"An assembly manipulated or<br>controlled by the government",
"An assembly representative<br>of the population", "Other")
(CCC_avis_en <- barres(data=rbind(dataKN(variables_CCC_avis, e1, miss=F), dataKN(variables_CCC_avis, e2, miss=F)), labels=labels_CCC_avis_long, legend = c("Wave 1", "Wave 2"), sort = T, grouped=T, rev = F, miss = F))
save_plotly(CCC_avis_en, width = 610, height = 650)
decrit(c$cause_CC_CCC)
c$cause_CC_CCC
library(memisc)
# options(download.file.method = "wget"); # For Ubuntu 14.04
package <- function(p, version = NULL) {
if (!is.element(p, installed.packages()[,1])) {
if (missing(version)) install.packages(p)
else {
package("remotes")
install_version(p, version = version, repos = "http://cran.us.r-project.org", upgrade = "never", dependencies = TRUE)
}
}
else { if(!missing(version)) warning(paste("'", p, "' is already installed with a (potentially) newer version. You may want to install the required version (", version, ") to avoid bugs.", sep=""))}
library(p, character.only = TRUE)
} # loads packages with automatical install if needed
package("memisc", version = "0.99.22")
decrit(c$cause_CC_CCC)
.libPaths(c("C:/Users/afabre/R-4.1.1/library", "C:/Users/afabre/R-4.0.3/library", "\\\\nash/mtec-home/afabre/My Documents/R/win-library/4.0"))
package("memisc", version = "0.99.22")
package("memisc")
decrit(c$cause_CC_CCC)
package("Hmisc")
package("ggplot2")
package('tidyverse')
# package("memisc", version = "0.99.22")
package("pillar")
package("Hmisc")
